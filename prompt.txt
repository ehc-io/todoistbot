<task>
based on the API definitions bellow, create a new feature for the todoist-bot.py script which allows specific projects to be bypassed from processing.
Design the feature in such a way that by default the script always bypasses the "inbox" project
If the user wants to bypass specific projects instead of inbox, it should provide the name of those project(s), separated by comma via this CLI parameter you create
</task>
<api-definitions>

- Get a user's projects
api = TodoistAPI("0123456789abcdef0123456789")

An example projects response:

[
    Project(
        id: "220474322",
        name: "Inbox",
        comment_count: 10,
        order: 0,
        color: "grey",
        is_shared: False,
        is_favorite: False,
        is_inbox_project: True,
        is_team_inbox: False,
        view_style: "list",
        url: "https://todoist.com/showProject?id=220474322",
        parent_id: None,
    )
]

try:
    projects = api.get_projects()
    print(projects)
except Exception as error:
    print(error)

- Get active tasks:

from todoist_api_python.api import TodoistAPI

api = TodoistAPI("0123456789abcdef0123456789")

try:
    tasks = api.get_tasks()
    print(tasks)
except Exception as error:
    print(error)

Example response:

[
    Task(
        creator_id: "2671355",
        created_at: "2019-12-11T22:36:50.000000Z",
        assignee_id: "2671362",
        assigner_id: "2671355",
        comment_count: 10,
        is_completed: False,
        content: "Buy Milk",
        description: "",
        due: {
            date: "2016-09-01",
            is_recurring: false,
            datetime: "2016-09-01T12:00:00.000000Z",
            string: "tomorrow at 12",
            timezone: "Europe/Moscow"
        },
        "duration": None,
        id: "2995104339",
        labels: ["Food", "Shopping"],
        order: 1,
        priority: 1,
        project_id: "2203306141",
        section_id: "7025",
        parent_id: "2995104589",
        url: "https://todoist.com/showTask?id=2995104339"
    )
]

</api-definitions>
<todoist-bot.py>
#!/usr/bin/env python3
import os
import re
import argparse
import time
from typing import List, Dict
from todoist_api_python.api import TodoistAPI
from datetime import datetime
from url_scraper import URLScraper

class URLExtractor:
    """Helper class to extract and clean URLs from text content."""
    
    @staticmethod
    def extract_markdown_urls(text: str) -> list[str]:
        """
        Extract URLs from text, handling both plain URLs and Markdown-formatted links.
        Returns a list of clean URLs.
        """
        # not include since it's not relevant to the problem


def get_api_key() -> str:
    # not include since it's not relevant to the problem


def process_task(api: TodoistAPI, task, mark_closed: bool) -> dict:
    """Process a single task and its URLs."""
    task_data = {
        'content': task.content,
        'description': task.description,
        'labels': task.labels,
        'urls_content': []
    }

    # Use the new URLExtractor to handle both Markdown and plain URLs
    urls = URLExtractor.extract_markdown_urls(task.content)
    if task.description:
        urls.extend(URLExtractor.extract_markdown_urls(task.description))

    # Remove duplicates while preserving order
    urls = list(dict.fromkeys(url for url in urls if URLScraper.is_valid_url(url)))

    for url in urls:
        scraped_content = URLScraper.scrape_url(url)
        if scraped_content:
            task_data['urls_content'].append({
                'url': url,
                'content': scraped_content['content']
            })

    if urls and mark_closed and task_data['urls_content']:
        try:
            api.close_task(task_id=task.id)
            print(f"[{datetime.now().strftime('%H:%M:%S')}] ✓ Task {task.id} marked as completed")
        except Exception as e:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] ✕ Failed to close task {task.id}: {str(e)}")

    return task_data

def write_markdown(tasks_data: List[dict], output_file: str):
    """Write tasks data to markdown file."""
    # not include since it's not relevant to the problem
            
def main():
    parser = argparse.ArgumentParser(description='Process Todoist tasks and extract URL contents')
    parser.add_argument('--project-id', help='Specific project ID to process')
    parser.add_argument('--no-close', action='store_true', help='Do not mark tasks as closed after processing')
    parser.add_argument('--output', help='Output file path')
    parser.add_argument('--max-tasks', type=int, help='Maximum number of tasks to process')
    args = parser.parse_args()

    api = TodoistAPI(get_api_key())
    try:
        tasks = api.get_tasks()
        if args.project_id:
            tasks = [t for t in tasks if t.project_id == args.project_id]
        if args.max_tasks:
            tasks = tasks[:args.max_tasks]

        tasks_data = []
        for task in tasks:
            print(f"[{datetime.now().strftime('%H:%M:%S')}] → Processing task: {task.content}")
            task_data = process_task(api, task, not args.no_close)
            tasks_data.append(task_data)

        output_file = args.output if args.output else f"{int(time.time())}.md"
        write_markdown(tasks_data, output_file)
        print(f"[{datetime.now().strftime('%H:%M:%S')}] ✓ Report written to: {output_file}")

    except Exception as error:
        print(f"[{datetime.now().strftime('%H:%M:%S')}] ✕ Fatal error: {str(error)}")
        exit(1)

if __name__ == "__main__":
    main()
    
</todoist-bot.py>